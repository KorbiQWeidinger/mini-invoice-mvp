---
description: These are general development rules/instructions for the project.
globs: src/**
alwaysApply: true
---

# Mini-Invoice MVP Developer Rules

## 🎯 Project Overview

This is a Next.js 15 application with TypeScript, Supabase backend, Preline UI components, and a semantic color token theming system. Focus on clean, maintainable, and scalable code.

## 🏗️ Architecture & Tech Stack

### Core Technologies

- **Next.js 15** with App Router and Turbopack
- **TypeScript** for type safety
- **Supabase** for backend (PostgreSQL, Auth, Real-time)
- **Preline UI** for component library
- **Tailwind CSS 4** with semantic color tokens
- **React 18** with modern patterns

### Theme System

- Uses semantic color tokens (CSS variables) for theming
- Three themes: Light, Dark, Coffee
- All colors must use semantic tokens: `bg-bg-primary`, `text-text-primary`, `border-border-primary`
- Never use hardcoded colors like `bg-blue-500` or `text-gray-900`
- Theme switching via `ThemeProvider` and `ThemeSwitcher` components

## 📏 Code Quality Standards

### Hard Limits (Non-negotiable)

- **Method/Function max length**: 30 lines
- **Component definition max length**: 100 lines
- **File max length**: 300 lines
- **Max nesting depth**: 3 levels
- **Max parameters per function**: 5

### Code Structure Rules

- **Use guard clauses** instead of nested if statements
- **Early returns** to reduce complexity
- **Single responsibility** - one function does one thing
- **Pure functions** when possible
- **Immutable data** - avoid direct mutations

### Example - Good vs Bad

```typescript
// ❌ BAD - Nested, long function
function processInvoice(invoice: Invoice, user: User, options: ProcessOptions) {
  if (invoice) {
    if (invoice.status === "draft") {
      if (user.role === "admin") {
        if (options.autoApprove) {
          // 20+ lines of logic here...
        }
      }
    }
  }
}

// ✅ GOOD - Guard clauses, short functions
function processInvoice(invoice: Invoice, user: User, options: ProcessOptions) {
  if (!invoice) return null;
  if (invoice.status !== "draft") return invoice;
  if (user.role !== "admin") return invoice;

  return autoApproveInvoice(invoice, options);
}

function autoApproveInvoice(invoice: Invoice, options: ProcessOptions) {
  // Max 30 lines of focused logic
}
```

## 🎨 UI/UX Guidelines

### Preline UI Usage

- Use Preline components for consistency: `hs-dropdown`, `hs-modal`, etc.
- Follow Preline's data attributes: `data-hs-dropdown`, `data-hs-modal`
- Initialize Preline components via `PrelineScript` component
- Use Preline's theme system integration

### Styling Rules

- **Always use semantic tokens**: `bg-bg-primary`, `text-text-primary`, `border-border-primary`
- **Never hardcode colors**: Avoid `bg-blue-500`, `text-gray-900`, etc.
- **Use Tailwind utilities**: Prefer `flex`, `grid`, `space-x-4` over custom CSS
- **Responsive design**: Mobile-first approach with `sm:`, `md:`, `lg:` breakpoints
- **Accessibility**: Include `aria-label`, `role`, and proper focus management

### Component Structure

```typescript
// ✅ GOOD - Clean component structure
interface ComponentProps {
  title: string;
  onAction: () => void;
}

export default function Component({ title, onAction }: ComponentProps) {
  // Early returns for edge cases
  if (!title) return null;

  // Hooks at the top
  const [state, setState] = useState();

  // Event handlers
  const handleClick = () => {
    onAction();
  };

  // Render
  return (
    <div className="bg-bg-primary text-text-primary">{/* Component JSX */}</div>
  );
}
```

## 🗄️ Database & API Rules

### Supabase Integration

- Use `supabase` client for client-side operations
- Use `invoiceService` and `invoiceItemService` for database operations
- Always handle errors gracefully with try-catch
- Use TypeScript types from `Database` interface

### API Routes

- Keep API routes focused and single-purpose
- Use proper HTTP status codes
- Validate input data
- Return consistent response formats

```typescript
// ✅ GOOD - Clean API route
export async function GET() {
  try {
    const invoices = await invoiceService.getAll();
    return Response.json({ data: invoices });
  } catch (error) {
    return Response.json(
      { error: "Failed to fetch invoices" },
      { status: 500 }
    );
  }
}
```

## 🔧 Development Practices

### File Organization

```
src/
├── app/                 # Next.js App Router pages
├── components/          # Reusable UI components
├── lib/                 # Utilities and services
├── types/               # TypeScript type definitions
└── styles/              # Global styles
```

### Naming Conventions

- **Files**: kebab-case (`invoice-service.ts`)
- **Components**: PascalCase (`InvoiceCard.tsx`)
- **Functions**: camelCase (`getInvoiceById`)
- **Constants**: UPPER_SNAKE_CASE (`API_BASE_URL`)
- **Types**: PascalCase (`Invoice`, `InvoiceItem`)

### Import Order

1. React imports
2. Next.js imports
3. Third-party libraries
4. Internal components
5. Types and utilities

```typescript
// ✅ GOOD - Proper import order
import { useState } from "react";
import Link from "next/link";
import { invoiceService } from "@/lib/database";
import Header from "@/components/Header";
import type { Invoice } from "@/types";
```

## 🚫 Anti-Patterns to Avoid

### Code Smells

- **Long parameter lists** - Use objects instead
- **Deep nesting** - Use guard clauses
- **Magic numbers** - Use named constants
- **Duplicate code** - Extract to functions
- **Large components** - Split into smaller ones

### Performance Anti-Patterns

- **Unnecessary re-renders** - Use `useMemo`, `useCallback`
- **Large bundle sizes** - Code splitting, lazy loading
- **Memory leaks** - Clean up subscriptions and timers

## 🧪 Testing Guidelines

### Test Structure

- **Unit tests** for utility functions
- **Component tests** for UI components
- **Integration tests** for API routes
- **E2E tests** for critical user flows

### Test Naming

```typescript
describe("InvoiceService", () => {
  describe("getById", () => {
    it("should return invoice when valid ID provided", () => {
      // Test implementation
    });

    it("should throw error when invalid ID provided", () => {
      // Test implementation
    });
  });
});
```

## 📝 Documentation Standards

### Code Comments

- **Why, not what** - Explain reasoning, not implementation
- **Complex business logic** - Document non-obvious decisions
- **API integrations** - Document external dependencies

### README Updates

- Keep README current with setup instructions
- Document environment variables
- Include deployment instructions

## 🔒 Security Guidelines

### Data Handling

- **Never expose** Supabase service role key on client
- **Validate all inputs** on both client and server
- **Sanitize data** before database operations
- **Use HTTPS** in production

### Authentication

- Implement proper user authentication
- Use Supabase Auth for user management
- Protect sensitive routes and API endpoints

## 🚀 Performance Standards

### Bundle Optimization

- **Code splitting** for large components
- **Lazy loading** for non-critical features
- **Image optimization** with Next.js Image component
- **Tree shaking** for unused code

### Runtime Performance

- **Minimize re-renders** with proper dependency arrays
- **Debounce** user input handlers
- **Virtualize** large lists
- **Cache** expensive computations

## 📊 Monitoring & Debugging

### Error Handling

- **Graceful degradation** for non-critical features
- **User-friendly error messages**
- **Proper error boundaries** for React components
- **Logging** for debugging purposes

### Development Tools

- **TypeScript strict mode** enabled
- **ESLint** for code quality
- **Prettier** for code formatting
- **React DevTools** for debugging

## 🎯 Success Metrics

### Code Quality

- **Zero TypeScript errors**
- **High test coverage** (>80%)
- **Fast build times** (<30s)
- **Small bundle size** (<500KB)

### User Experience

- **Fast page loads** (<2s)
- **Smooth animations** (60fps)
- **Accessible** (WCAG 2.1 AA)
- **Mobile responsive**

---

**Remember**: These rules exist to create maintainable, scalable, and high-quality software. When in doubt, prioritize readability and maintainability over cleverness.
